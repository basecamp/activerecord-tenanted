#!/usr/bin/env ruby

GEM_PATH     = File.expand_path(File.join(__dir__, "../"))
SMARTY_PATH  = File.join(GEM_PATH, "test/smarty")
GEMFILE      = File.join(GEM_PATH, "Gemfile")
OVERLAY_PATH = File.join(GEM_PATH, "test/integration")

TEST_ARGS = ARGV.dup
OPT_KEEP_DIR = TEST_ARGS.delete("--keep") # keep the test tempdirs around for examination

ENV["BUNDLE_GEMFILE"] = GEMFILE
require "bundler/setup"

PARALLEL = ENV["NCPU"].to_i > 1

require "fileutils"
require "tmpdir"
require "yaml"
require "open3"
require "erb"
require "debug"
require "active_support"
require "active_support/core_ext/object" # deep_dup

scenarios = Dir.glob("test/scenarios/*/*db/*record.rb").map do |path|
  adapter, database, models = path.scan(%r{test/scenarios/(.+)/(.+db)/(.+record).rb}).flatten
  { adapter: adapter, database: database, models: models }
end

# Filter by adapter if ADAPTER environment variable is set
if ENV["ADAPTER"]
  adapter_filter = ENV["ADAPTER"].downcase
  scenarios.select! { |s| s[:adapter] == adapter_filter }
  abort("No scenarios found for adapter: #{adapter_filter}") if scenarios.empty?
end

COLOR_FG_BLUE = "\e[0;34m"
COLOR_RESET = "\e[0m"

def run_cmd(scenario, cmd, verbose: false, env: {})
  message = "#{COLOR_FG_BLUE}#{scenario}#{COLOR_RESET} > #{env.presence} #{cmd}"
  print message + (PARALLEL ? "\n" : "")

  output = status = nil
  elapsed = ActiveSupport::Benchmark.realtime do
    output, status = Open3.capture2e(env, cmd)
  end

  puts " (#{elapsed.round(2)}s)" if !PARALLEL
  puts output if verbose || !status.success? || ENV["CI"]

  abort("ERROR: Command failed") unless status.success?
end

def run_scenario(scenario)
  # setup the test directory and cleanup
  app_path = Dir.mktmpdir("activerecord-tenanted-integration-test-")
  at_exit { FileUtils.remove_entry app_path } unless OPT_KEEP_DIR
  puts "Creating integration app for #{COLOR_FG_BLUE}#{scenario}#{COLOR_RESET} at #{app_path}"

  # Generate a unique database prefix for this scenario to avoid conflicts
  # Use a very short prefix to avoid PostgreSQL's 63-character identifier limit
  # Format: t<pid> (process ID is already unique enough for concurrent runs)
  db_prefix = "t#{Process.pid}"

  # make a copy of the smarty app
  FileUtils.copy_entry(SMARTY_PATH, app_path)

  # Set environment variables for ERB processing
  ENV["POSTGRES_UNIQUE_PREFIX"] = db_prefix if scenario[:adapter] == "postgresql"
  ENV["MYSQL_UNIQUE_PREFIX"] = db_prefix if scenario[:adapter] == "mysql"

  # generate database file
  database_file = File.join(GEM_PATH, "test/scenarios/#{scenario[:adapter]}/#{scenario[:database]}/database.yml")
  erb_content = ERB.new(File.read(database_file)).result
  storage_path = File.join(app_path, "storage")
  db_path = File.join(app_path, "db")
  database_file_contents = sprintf(erb_content, storage: storage_path, db_path: db_path)
  database_file_hash = YAML.unsafe_load(database_file_contents)
  database_file_hash["development"] = database_file_hash["test"].deep_dup
  database_file_hash["development"].each_value do |hash|
    hash["database"] = hash["database"].sub("/test/", "/development/")
  end
  File.write(File.join(app_path, "config/database.yml"), database_file_hash.to_yaml)

  # generate models using ApplicationRecord
  models_file = File.join(GEM_PATH, "test/scenarios/#{scenario[:adapter]}/#{scenario[:database]}/#{scenario[:models]}.rb")
  models_file_contents = File.read(models_file)
                           .gsub("TenantedApplicationRecord", "ApplicationRecord")
  File.write(File.join(app_path, "app/models/application_record.rb"), models_file_contents)

  # copy migrations from scenario and smarty app
  FileUtils.mkdir_p(File.join(app_path, "db"))
  FileUtils.cp_r(Dir.glob(File.join(GEM_PATH, "test/scenarios/#{scenario[:adapter]}/#{scenario[:database]}/*migrations")),
                 File.join(app_path, "db"))
  FileUtils.cp_r(Dir.glob(File.join(app_path, "db/migrate/*rb")),
                 File.join(app_path, "db/tenanted_migrations"))

  # copy overlay tests and tenanting config
  FileUtils.cp_r(Dir.glob(File.join(OVERLAY_PATH, "*")), app_path)

  Dir.chdir(app_path) do
    Bundler.with_original_env do
      run_cmd(scenario, "bundle check || bundle install")

     adapter_config = {"RAILS_ENV" => "test","ARTENANT_SCHEMA_DUMP" => "1"}
     if scenario[:adapter] == "mysql"
       adapter_config.merge!({ "MYSQL_UNIQUE_PREFIX" => db_prefix })
     elsif scenario[:adapter] == "postgresql"
       adapter_config.merge!({ "POSTGRES_UNIQUE_PREFIX" => db_prefix })
     end

      # Drop existing databases to ensure fresh setup
      run_cmd(scenario, "bin/rails db:drop", env: { **adapter_config }) rescue nil

      run_cmd(scenario, "bin/rails db:prepare", env: { **adapter_config })

      # validate-ish the setup
      prefix = scenario[:database].match?(/\Asecondary/) ? "tenanted_" : ""
      File.exist?("db/#{prefix}schema.rb") || abort("Schema dump not generated")
      File.exist?("db/#{prefix}schema_cache.yml") || abort("Schema cache dump not generated")

      # run in parallel half the time, but only when we're in parallel mode
      #  (otherwise it can cause deadlocks with PostgreSQL)
      env = if PARALLEL && rand(2).zero?
        { "PARALLEL_WORKERS" => "2" }
      else
        { "PARALLEL_WORKERS" => "1" }
      end

      run_cmd(scenario, ["bin/rails test", *TEST_ARGS].join(" "), verbose: true, env:)
    ensure
      ENV["BUNDLE_GEMFILE"] = nil
    end
  end
end

if PARALLEL
  processes = {}

  scenarios.each do |scenario|
    processes[scenario] = Process.fork do
      run_scenario(scenario)
    end
  end

  statuses = {}

  processes.each do |scenario, pid|
    statuses[scenario] = Process::Status.wait(pid)
  end

  failure = false
  statuses.each do |scenario, status|
    scenario = "#{COLOR_FG_BLUE}#{scenario}#{COLOR_RESET}"
    if status.success?
      puts "Scenario #{scenario} succeeded."
    else
      puts "Scenario #{scenario} FAILED."
      failure = true
    end
  end
  exit(1) if failure
else
  scenarios.each do |scenario|
    run_scenario(scenario)
  end
end
